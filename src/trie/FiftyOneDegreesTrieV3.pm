# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package FiftyOneDegreesTrieV3;
use base qw(Exporter);
use base qw(DynaLoader);
package FiftyOneDegreesTrieV3c;
bootstrap FiftyOneDegreesTrieV3;
package FiftyOneDegreesTrieV3;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package FiftyOneDegreesTrieV3;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package FiftyOneDegreesTrieV3;


############# Class : FiftyOneDegreesTrieV3::MapStringString ##############

package FiftyOneDegreesTrieV3::MapStringString;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( FiftyOneDegreesTrieV3 );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = FiftyOneDegreesTrieV3c::new_MapStringString(@_);
    bless $self, $pkg if defined($self);
}

*size = *FiftyOneDegreesTrieV3c::MapStringString_size;
*empty = *FiftyOneDegreesTrieV3c::MapStringString_empty;
*clear = *FiftyOneDegreesTrieV3c::MapStringString_clear;
*get = *FiftyOneDegreesTrieV3c::MapStringString_get;
*set = *FiftyOneDegreesTrieV3c::MapStringString_set;
*del = *FiftyOneDegreesTrieV3c::MapStringString_del;
*has_key = *FiftyOneDegreesTrieV3c::MapStringString_has_key;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        FiftyOneDegreesTrieV3c::delete_MapStringString($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : FiftyOneDegreesTrieV3::VectorString ##############

package FiftyOneDegreesTrieV3::VectorString;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( FiftyOneDegreesTrieV3 );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = FiftyOneDegreesTrieV3c::new_VectorString(@_);
    bless $self, $pkg if defined($self);
}

*size = *FiftyOneDegreesTrieV3c::VectorString_size;
*empty = *FiftyOneDegreesTrieV3c::VectorString_empty;
*clear = *FiftyOneDegreesTrieV3c::VectorString_clear;
*push = *FiftyOneDegreesTrieV3c::VectorString_push;
*pop = *FiftyOneDegreesTrieV3c::VectorString_pop;
*get = *FiftyOneDegreesTrieV3c::VectorString_get;
*set = *FiftyOneDegreesTrieV3c::VectorString_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        FiftyOneDegreesTrieV3c::delete_VectorString($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : FiftyOneDegreesTrieV3::Match ##############

package FiftyOneDegreesTrieV3::Match;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( FiftyOneDegreesTrieV3 );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        FiftyOneDegreesTrieV3c::delete_Match($self);
        delete $OWNER{$self};
    }
}

*getValues = *FiftyOneDegreesTrieV3c::Match_getValues;
*getValue = *FiftyOneDegreesTrieV3c::Match_getValue;
*getDeviceId = *FiftyOneDegreesTrieV3c::Match_getDeviceId;
*getRank = *FiftyOneDegreesTrieV3c::Match_getRank;
*getDifference = *FiftyOneDegreesTrieV3c::Match_getDifference;
*getMethod = *FiftyOneDegreesTrieV3c::Match_getMethod;
*getUserAgent = *FiftyOneDegreesTrieV3c::Match_getUserAgent;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : FiftyOneDegreesTrieV3::Provider ##############

package FiftyOneDegreesTrieV3::Provider;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( FiftyOneDegreesTrieV3 );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        FiftyOneDegreesTrieV3c::delete_Provider($self);
        delete $OWNER{$self};
    }
}

*getHttpHeaders = *FiftyOneDegreesTrieV3c::Provider_getHttpHeaders;
*getAvailableProperties = *FiftyOneDegreesTrieV3c::Provider_getAvailableProperties;
*getDataSetName = *FiftyOneDegreesTrieV3c::Provider_getDataSetName;
*getDataSetFormat = *FiftyOneDegreesTrieV3c::Provider_getDataSetFormat;
*getDataSetPublishedDate = *FiftyOneDegreesTrieV3c::Provider_getDataSetPublishedDate;
*getDataSetNextUpdateDate = *FiftyOneDegreesTrieV3c::Provider_getDataSetNextUpdateDate;
*getDataSetSignatureCount = *FiftyOneDegreesTrieV3c::Provider_getDataSetSignatureCount;
*getDataSetDeviceCombinations = *FiftyOneDegreesTrieV3c::Provider_getDataSetDeviceCombinations;
*getMatch = *FiftyOneDegreesTrieV3c::Provider_getMatch;
*getMatchWithTolerances = *FiftyOneDegreesTrieV3c::Provider_getMatchWithTolerances;
*getMatchJson = *FiftyOneDegreesTrieV3c::Provider_getMatchJson;
*setDrift = *FiftyOneDegreesTrieV3c::Provider_setDrift;
*setDifference = *FiftyOneDegreesTrieV3c::Provider_setDifference;
*reloadFromFile = *FiftyOneDegreesTrieV3c::Provider_reloadFromFile;
*reloadFromMemory = *FiftyOneDegreesTrieV3c::Provider_reloadFromMemory;
*getIsThreadSafe = *FiftyOneDegreesTrieV3c::Provider_getIsThreadSafe;
sub new {
    my $pkg = shift;
    my $self = FiftyOneDegreesTrieV3c::new_Provider(@_);
    bless $self, $pkg if defined($self);
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package FiftyOneDegreesTrieV3;

1;
